<!DOCTYPE html>
<!--suppress ALL -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>mathematicalModeling</title>
    <link href="../static/css/code.css" rel="stylesheet" type="text/css">
    <style>
        .tit{
            text-align:center;
        }
        div{
            font-size:20px;
        }
    </style>
</head>
<body>
    <div class="tit">
        <span style="color:red;font-size:40px;">曲线拟合问题</span>
    </div>
    <ol type="I">
        <li>
            <div>这里由于没有数据，先生成实验数据</div>
            <div>首先目标曲线：</div>
            <div><img src="../static/Math/mathematicalModeling/1.png"></div>
            <div><img src="../static/Math/mathematicalModeling/2.png"></div>
            <div>生成曲线数据方法如下：</div>
            <pre id="code_block">
                <span><code>import numpy as np</code></span>
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code>from scipy.stats import norm</code></span>
                <span><code></code></span>
                <span><code>def function(x, a , b, f, phi):</code></span>
                <span><code>    result = a * np.exp(-b * np.sin(f * x + phi))</code></span>
                <span><code>    return result</code></span>
                <span><code></code></span>
                <span><code>x = np.linspace(0, 2 * np.pi, 50)</code></span>
                <span><code>actual_parameters = [3, 2, 1.25, np.pi / 4]</code></span>
                <span><code>y = function(x, *actual_parameters)</code></span>
                <span><code>y_noisy = y + 0.8 * norm.rvs(size=len(x))</code></span>
            </pre>
            <div>生成数据如下：</div>
            <table border="4">
                <tr>
                    <th>X</th>
                    <th>y</th>
                </tr>
                <tr>
                    <td>0.2236457993127439</td>
                    <td>0.0</td>
                </tr>
                <tr>
                    <td>1.4472239795989474</td>
                    <td>0.1282282715750936</td>
                </tr>
                <tr>
                    <td>1.5792959120790648</td>
                    <td>0.2564565431501872</td>
                </tr>
                <tr>
                    <td>0.6778526748445148</td>
                    <td>0.3846848147252807</td>
                </tr>
                <tr>
                    <td>-0.6797746530946486</td>
                    <td>0.5129130863003744</td>
                </tr>
                <tr>
                    <td>-1.345488810309232</td>
                    <td>0.6411413578754679</td>
                </tr>
                <tr>
                    <td>0.4305698669877983</td>
                    <td>0.7693696294505615</td>
                </tr>
                <tr>
                    <td>0.2225439327873096</td>
                    <td>0.8975979010256552</td>
                </tr>
                <tr>
                    <td>0.5563458625209984</td>
                    <td>1.0258261726007487</td>
                </tr>
                <tr>
                    <td>0.9735430216325486</td>
                    <td>1.1540544441758422</td>
                </tr>
                <tr>
                    <td>1.6505242044568138</td>
                    <td>1.2822827157509358</td>
                </tr>
                <tr>
                    <td>2.2295451677583267</td>
                    <td>1.4105109873260295</td>
                </tr>
                <tr>
                    <td>1.628960353649783</td>
                    <td>1.538739258901123</td>
                </tr>
                <tr>
                    <td>0.9288338406419172</td>
                    <td>1.6669675304762166</td>
                </tr>
                <tr>
                    <td>2.2110209441001736</td>
                    <td>1.7951958020513104</td>
                </tr>
                <tr>
                    <td>3.999369944623464</td>
                    <td>1.923424073626404</td>
                </tr>
                <tr>
                    <td>3.9376386726741193</td>
                    <td>2.0516523452014974</td>
                </tr>
                <tr>
                    <td>4.657941910308808</td>
                    <td>2.179880616776591</td>
                </tr>
                <tr>
                    <td>7.331812028544913</td>
                    <td>2.3081088883516845</td>
                </tr>
                <tr>
                    <td>9.774651123767196</td>
                    <td>2.436337159926778</td>
                </tr>
                <tr>
                    <td>13.072575654860648</td>
                    <td>2.564565431501872</td>
                </tr>
                <tr>
                    <td>16.046094983549896</td>
                    <td>2.692793703076965</td>
                </tr>
                <tr>
                    <td>18.481085161260022</td>
                    <td>2.821021974652059</td>
                </tr>
                <tr>
                    <td>19.58699050741213</td>
                    <td>2.9492502462271526</td>
                </tr>
                <tr>
                    <td>22.04319094067442</td>
                    <td>3.077478517802246</td>
                </tr>
                <tr>
                    <td>22.02385348945999</td>
                    <td>3.20570678937734</td>
                </tr>
                <tr>
                    <td>20.503432658529263</td>
                    <td>3.333935060952433</td>
                </tr>
                <tr>
                    <td>18.85461977186076</td>
                    <td>3.4621633325275267</td>
                </tr>
                <tr>
                    <td>16.802089091952716</td>
                    <td>3.5903916041026207</td>
                </tr>
                <tr>
                    <td>13.11532042210773</td>
                    <td>3.718619875677714</td>
                </tr>
                <tr>
                    <td>11.297549961853283</td>
                    <td>3.846848147252808</td>
                </tr>
                <tr>
                    <td>7.747740727077016</td>
                    <td>3.975076418827901</td>
                </tr>
                <tr>
                    <td>5.728927390707121</td>
                    <td>4.103304690402995</td>
                </tr>
                <tr>
                    <td>5.125876657542555</td>
                    <td>4.231532961978089</td>
                </tr>
                <tr>
                    <td>3.378692145170281</td>
                    <td>4.359761233553182</td>
                </tr>
                <tr>
                    <td>2.7147610622780087</td>
                    <td>4.487989505128276</td>
                </tr>
                <tr>
                    <td>2.305721533048369</td>
                    <td>4.616217776703369</td>
                </tr>
                <tr>
                    <td>0.8972099977883041</td>
                    <td>4.744446048278463</td>
                </tr>
                <tr>
                    <td>-0.1996605132227342</td>
                    <td>4.872674319853556</td>
                </tr>
                <tr>
                    <td>1.243082834436828</td>
                    <td>5.00090259142865</td>
                </tr>
                <tr>
                    <td>-0.1275325117242889</td>
                    <td>5.129130863003743</td>
                </tr>
                <tr>
                    <td>1.0871655290227444</td>
                    <td>5.257359134578837</td>
                </tr>
                <tr>
                    <td>-0.7857412983994341</td>
                    <td>5.385587406153931</td>
                </tr>
                <tr>
                    <td>0.7708997393738456</td>
                    <td>5.513815677729024</td>
                </tr>
                <tr>
                    <td>0.6419152273260361</td>
                    <td>5.642043949304118</td>
                </tr>
                <tr>
                    <td>-0.2359115509562813</td>
                    <td>5.770272220879211</td>
                </tr>
                <tr>
                    <td>0.443110821073647</td>
                    <td>5.898500492454305</td>
                </tr>
                <tr>
                    <td>1.4139827980946416</td>
                    <td>6.026728764029398</td>
                </tr>
                <tr>
                    <td>0.6262415653904855</td>
                    <td>6.154957035604492</td>
                </tr>
                <tr>
                    <td>1.1785639400214245</td>
                    <td>6.283185307179586</td>
                </tr>
            </table>
            <div><img src="../static/Math/mathematicalModeling/3.png"></div>
        </li>
        <li>
            <div>最小二乘法拟合</div>
            <pre id="code_block">
                <span><code>from scipy.optimize import curve_fit</code></span>
                <span><code>p_est,err_est = curve_fit(function, x, y_noisy)</code></span>
                <span><code>print(p_est)</code></span>
            </pre>
            <div>我们得到了系数的解</div>
            <table border="4">
                <tr>
                    <th>参数</th>
                    <th>计算得到的</th>
                    <th>原函数</th>
                </tr>
                <tr>
                    <td>a</td>
                    <td>3.12367656</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>b</td>
                    <td>1.9478261</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>f</td>
                    <td>1.28744683</td>
                    <td>1.25</td>
                </tr>
                <tr>
                    <td>phi</td>
                    <td>0.6444031</td>
                    <td>0.7853981</td>
                </tr>
            </table>
            <div><img src="../static/Math/mathematicalModeling/4.png"></div>
        </li>
        <li>
            <div>误差分析</div>
            <pre id="code_block">
                <span><code>print(err_est)</code></span>
            </pre>
            <div>可以得到协方差矩阵</div>
            <img src="../static/Math/mathematicalModeling/5.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">Lagrange乘数法</span>
    </div>
    <ol type="I">
        <li>
            <div>这里由于没有数据，先生成实验数据</div>
            <div>生成曲线数据方法如下：</div>
            <pre id="code_block">
                <span><code>import numpy as np</code></span>
                <span><code></code></span>
                <span><code>x = np.linspace(0,5,10)</code></span>
                <span><code>y = 2*x</code></span>
                <span><code>r = np.random.RandomState(42)</code></span>
                <span><code>y += r.randn(10)</code></span>
            </pre>
            <div><img src="../static/Math/mathematicalModeling/6.png"></div>
        </li>
        <li>
            <div>Lagrange乘数法的实现</div>
            <pre id="code_block">
                <span><code>def p(args, ex):</code></span>
                <span><code>    def loop(largs):</code></span>
                <span><code>        if len(largs) == 1: return [1, -largs[0]]</code></span>
                <span><code>        dp = loop(largs[1:])</code></span>
                <span><code>        return [-largs[0] * i + j for i, j in zip([0] + dp, dp + [0])]</code></span>
                <span><code></code></span>
                <span><code>    largs = list(args)</code></span>
                <span><code>    largs.remove(ex)</code></span>
                <span><code>    div = 1</code></span>
                <span><code>    for i in largs:</code></span>
                <span><code>        div *= ex[0] - i[0]</code></span>
                <span><code>    return [i * ex[1] / div for i in loop(list(zip(*largs))[0])]</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>def Lagrange(*args):</code></span>
                <span><code>    lists = [p(args, i) for i in args]</code></span>
                <span><code>    ans = [sum(i) for i in zip(*lists)]</code></span>
                <span><code>    ans.reverse()</code></span>
                <span><code></code></span>
                <span><code>    def rtn_func(x):</code></span>
                <span><code>        return sum([a * x ** i for i, a in enumerate(ans)])</code></span>
                <span><code></code></span>
                <span><code>    return rtn_func</code></span>
            </pre>
        </li>
        <li>
            <div>拟合分析</div>
            <pre id="code_block">
                <span><code>func = Lagrange(*zip(x, y))</code></span>
                <span><code>x = np.arange(0, 5.1, 0.1)</code></span>
                <span><code>y = [func(i) for i in x]</code></span>
            </pre>
            <div><img src="../static/Math/mathematicalModeling/7.png"></div>
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">退火算法</span>
    </div>
    <ol type="I">
        <li>
            <div>原理讲解：</div>
            <div style="text-indent:2em;">假设前一个状态为x(n),系统根据某一指标（梯度下降，上节的能量），状态变为x(n+1),相应的，系统的能量由E(n)变为E(n+1),定义系统由x(n)变为x(n+1)的接受概率P为：</div>
            <div><img src="../static/Math/mathematicalModeling/8.png"></div>

            <div style="text-indent:2em;">从上式我们可以看到，如果能量减小了，那么这种转移就被接受（概率为1），如果能量增大了，就说明系统偏离全局最优值位置更远了，此时算法不会立刻将其抛弃，而是进行概率操作：首先在区间【0,1】产生一个均匀分布的随机数ϵ，如果ϵ&lt;P，则此种转移接受，否则拒绝转移，进入下一步，往复循环。其中P以能量的变化量和T进行决定概率P的大小，所以这个值是动态的。</div>
            <div style="text-indent:2em;">用固体退火模拟组合优化问题，将内能E模拟为目标函数值f，温度T演化成控制参数t，即得到解组合优化问题的模拟退火算法：由初始解i和控制参数初值t开始，对当前解重复“产生新解→计算目标函数差→接受或舍弃”的迭代，并逐步衰减t值，算法终止时的当前解即为所得近似最优解，退火过程由冷却进度表(Cooling Schedule)控制，包括控制参数的初值t及其衰减因子Δt、每个t值时的迭代次数L和停止条件Tf。而温度的作用就是来计算转移概率P的。当温度每次下降后，转移概率也发生变化，因此在所有温度下迭代L次的结果也都是不相同的。在每个温度下迭代L次来寻找当前温度下的最优解，然后降低温度继续寻找，直到到达终止温度，即转移概率P接近于0</div>
            <div style="text-indent:2em;">接受状态的三条原则：</div>
            <ol style="1">
                <li>在固定温度下，接受使目标函数下降的候选解的概率要大于使目标函数上升的候选解概率；</li>
                <li>随着温度的下降，接受使目标函数上升的解的概率要逐渐减小；</li>
                <li>当温度趋于零时，只能接受目标函数下降的解。</li>
            </ol>
        </li>
        <li>
            <div>流程分析</div>
            <div><img src="../static/Math/mathematicalModeling/9.png"></div>
        </li>
        <li>
            <div>代码实现</div>
            <div><img src="../static/Math/mathematicalModeling/10.png"></div>
            <pre id="code_block">
                <span><code>import numpy as np</code></span>
                <span><code>from random import random</code></span>
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>def func(x, y):  # 函数优化问题</code></span>
                <span><code>    res = 4 * x ** 2 - 2.1 * x ** 4 + x ** 6 / 3 + x * y - 4 * y ** 2 + 4 * y ** 4</code></span>
                <span><code>    return res</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code># x为公式里的x1,y为公式里面的x2</code></span>
                <span><code>class SA:</code></span>
                <span><code>    def __init__(self, func, iter=100, T0=100, Tf=0.01, alpha=0.99):</code></span>
                <span><code>        self.func = func</code></span>
                <span><code>        self.iter = iter  # 内循环迭代次数,即为L =100</code></span>
                <span><code>        self.alpha = alpha  # 降温系数，alpha=0.99</code></span>
                <span><code>        self.T0 = T0  # 初始温度T0为100</code></span>
                <span><code>        self.Tf = Tf  # 温度终值Tf为0.01</code></span>
                <span><code>        self.T = T0  # 当前温度</code></span>
                <span><code>        self.x = [random() * 11 - 5 for i in range(iter)]  # 随机生成100个x的值</code></span>
                <span><code>        self.y = [random() * 11 - 5 for i in range(iter)]  # 随机生成100个y的值</code></span>
                <span><code>        self.most_best = []</code></span>
                <span><code>        """</code></span>
                <span><code>        random()这个函数取0到1之间的小数</code></span>
                <span><code>        如果你要取0-10之间的整数（包括0和10）就写成 (int)random()*11就可以了，11乘以零点多的数最大是10点多，最小是0点多</code></span>
                <span><code>        该实例中x1和x2的绝对值不超过5（包含整数5和-5），（random() * 11 -5）的结果是-6到6之间的任意值（不包括-6和6）</code></span>
                <span><code>        （random() * 10 -5）的结果是-5到5之间的任意值（不包括-5和5），所有先乘以11，取-6到6之间的值，产生新解过程中，用一个if条件语句把-5到5之间（包括整数5和-5）的筛选出来。</code></span>
                <span><code>        """</code></span>
                <span><code>        self.history = {'f': [], 'T': []}</code></span>
                <span><code></code></span>
                <span><code>    def generate_new(self, x, y):  # 扰动产生新解的过程</code></span>
                <span><code>        while True:</code></span>
                <span><code>            x_new = x + self.T * (random() - random())</code></span>
                <span><code>            y_new = y + self.T * (random() - random())</code></span>
                <span><code>            if (-5 <= x_new <= 5) & (-5 <= y_new <= 5):</code></span>
                <span><code>                break  # 重复得到新解，直到产生的新解满足约束条件</code></span>
                <span><code>        return x_new, y_new</code></span>
                <span><code></code></span>
                <span><code>    def Metrospolis(self, f, f_new):  # Metropolis准则</code></span>
                <span><code>        if f_new <= f:</code></span>
                <span><code>            return 1</code></span>
                <span><code>        else:</code></span>
                <span><code>            p = np.exp((f - f_new) / self.T)</code></span>
                <span><code>            if random() < p:</code></span>
                <span><code>                return 1</code></span>
                <span><code>            else:</code></span>
                <span><code>                return 0</code></span>
                <span><code></code></span>
                <span><code>    def best(self):  # 获取最优目标函数值</code></span>
                <span><code>        f_list = []  # f_list数组保存每次迭代之后的值</code></span>
                <span><code>        for i in range(self.iter):</code></span>
                <span><code>            f = self.func(self.x[i], self.y[i])</code></span>
                <span><code>            f_list.append(f)</code></span>
                <span><code>        f_best = min(f_list)</code></span>
                <span><code></code></span>
                <span><code>        idx = f_list.index(f_best)</code></span>
                <span><code>        return f_best, idx  # f_best,idx分别为在该温度下，迭代L次之后目标函数的最优解和最优解的下标</code></span>
                <span><code></code></span>
                <span><code>    def run(self):</code></span>
                <span><code>        count = 0</code></span>
                <span><code>        # 外循环迭代，当前温度小于终止温度的阈值</code></span>
                <span><code>        while self.T > self.Tf:</code></span>
                <span><code></code></span>
                <span><code>            # 内循环迭代100次</code></span>
                <span><code>            for i in range(self.iter):</code></span>
                <span><code>                f = self.func(self.x[i], self.y[i])  # f为迭代一次后的值</code></span>
                <span><code>                x_new, y_new = self.generate_new(self.x[i], self.y[i])  # 产生新解</code></span>
                <span><code>                f_new = self.func(x_new, y_new)  # 产生新值</code></span>
                <span><code>                if self.Metrospolis(f, f_new):  # 判断是否接受新值</code></span>
                <span><code>                    self.x[i] = x_new  # 如果接受新值，则把新值的x,y存入x数组和y数组</code></span>
                <span><code>                    self.y[i] = y_new</code></span>
                <span><code>            # 迭代L次记录在该温度下最优解</code></span>
                <span><code>            ft, _ = self.best()</code></span>
                <span><code>            self.history['f'].append(ft)</code></span>
                <span><code>            self.history['T'].append(self.T)</code></span>
                <span><code>            # 温度按照一定的比例下降（冷却）</code></span>
                <span><code>            self.T = self.T * self.alpha</code></span>
                <span><code>            count += 1</code></span>
                <span><code></code></span>
                <span><code>            # 得到最优解</code></span>
                <span><code>        f_best, idx = self.best()</code></span>
                <span><code>        print(f"F={f_best}, x={self.x[idx]}, y={self.y[idx]}")</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>sa = SA(func)</code></span>
                <span><code>sa.run()</code></span>
            </pre>
            <div>结果如下</div>
            <div><img src="../static/Math/mathematicalModeling/11.png"></div>
            <div>退火过程可视化</div>
            <div>代码</div>
            <pre id="code_block">
                <span><code>plt.plot(sa.history['T'], sa.history['f'])</code></span>
                <span><code>plt.title('SA')</code></span>
                <span><code>plt.xlabel('T')</code></span>
                <span><code>plt.ylabel('f')</code></span>
                <span><code>plt.gca().invert_xaxis()</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <div><img src="../static/Math/mathematicalModeling/12.png"></div>
        </li>
        <li>
            <div>解最小值问题</div>
            <div>解上述问题</div>
            <pre id="code_block">
                <span><code>from sko.SA import SA</code></span>
                <span><code>def demo_func(x):</code></span>
                <span><code>    x1, x2 = x</code></span>
                <span><code>    return 4 * x1 ** 2 - 2.1 * x1 ** 4 + x1 ** 6 / 3 + x1 * x2 - 4 * x2 ** 2 + 4 * x2 ** 4</code></span>
                <span><code></code></span>
                <span><code>sa = SA(func=demo_func, x0=[1, 1])</code></span>
                <span><code>x_star, y_star = sa.run()</code></span>
                <span><code>print(x_star, y_star)</code></span>
            </pre>
            <div><img src="../static/Math/mathematicalModeling/13.png"></div>
            <div>退火过程可视化</div>
            <pre id="code_block">
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code>import pandas as pd</code></span>
                <span><code></code></span>
                <span><code>plt.plot(pd.DataFrame(sa.best_y_history).cummin(axis=0))</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <div><img src="../static/Math/mathematicalModeling/14.png"></div>
        </li>
        <li>
            <div>旅行商问题</div>
            <pre id="code_block">
                <span><code>import numpy as np</code></span>
                <span><code>from scipy import spatial</code></span>
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code></code></span>
                <span><code>num_points = 50</code></span>
                <span><code></code></span>
                <span><code>points_coordinate = np.random.rand(num_points, 2)  # 生成点坐标</code></span>
                <span><code>distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric='euclidean')  # 距离矩阵</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>def cal_total_distance(routine):</code></span>
                <span><code>    """</code></span>
                <span><code>    The objective function. input routine, return total distance.</code></span>
                <span><code>    cal_total_distance(np.arange(num_points))</code></span>
                <span><code>    """</code></span>
                <span><code>    num_points, = routine.shape</code></span>
                <span><code>    return sum([distance_matrix[routine[i % num_points], routine[(i + 1) % num_points]] for i in range(num_points)])</code></span>
                <span><code></code></span>
                <span><code>from sko.SA import SA_TSP</code></span>
                <span><code></code></span>
                <span><code>sa_tsp = SA_TSP(func=cal_total_distance, x0=range(num_points),T_max=100,T_min=1,L=10*num_points)</code></span>
                <span><code></code></span>
                <span><code>best_points, best_distance = sa_tsp.run()</code></span>
                <span><code>print(best_points, best_distance)</code></span>
            </pre>
            <div>可视化</div>
            <pre id="code_block">
                <span><code>from matplotlib.ticker import FormatStrFormatter</code></span>
                <span><code></code></span>
                <span><code>fig, ax = plt.subplots(1, 2)</code></span>
                <span><code>best_points_ = np.concatenate([best_points, [best_points[0]]])</code></span>
                <span><code>best_points_coordinate = points_coordinate[best_points_, :]</code></span>
                <span><code>ax[0].plot(sa_tsp.best_y_history)</code></span>
                <span><code>ax[0].set_xlabel("Iteration")</code></span>
                <span><code>ax[0].set_ylabel("Distance")</code></span>
                <span><code>ax[1].plot(best_points_coordinate[:, 0], best_points_coordinate[:, 1],</code></span>
                <span><code>           marker='o', markerfacecolor='b', color='c', linestyle='-')</code></span>
                <span><code>ax[1].xaxis.set_major_formatter(FormatStrFormatter('%.3f'))</code></span>
                <span><code>ax[1].yaxis.set_major_formatter(FormatStrFormatter('%.3f'))</code></span>
                <span><code>ax[1].set_xlabel("Longitude")</code></span>
                <span><code>ax[1].set_ylabel("Latitude")</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <div><img src="../static/Math/mathematicalModeling/15.png"></div>
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">差分进化算法</span>
    </div>
    <ol type="I">
        <li>
            <div>原理讲解</div>
            <ol type="i">
                <li>
                    <div>初始化参数</div>
                    <div>在差分进化算法中，有几个参数比较重要，突变参数F，交叉概率Cr，种群数Np，个体维度D；这里需要注意F，Cr的取值范围通常在（0，1），但是不意味不能取超过1，这是在大多数的情况都是取（0，1）。关于种群数和个体的关系通常是Np=5D~10D，种群数也是影响整体算法的因素之一。初始化种群之后，接下来进行初始化种群。</div>
                </li>
                <li>
                    <div>初始种群</div>
                    <div>初始化种群X通常需要结合决策空间的上界和下届，分别为xmax,xmin，具体的计算如下：</div>
                    <img src="../static/Math/mathematicalModeling/16.png">
                    <div>这样以决策空间边界的初始种群被建立，用于后期的变异，交叉。其中xmax(j)，xmin(j)表示决策空间j的上界和下届。</div>
                </li>
                <li>
                    <div>种群变异</div>
                    <div>经历了初始化种群之后，对其进行变异产生变异向量，为后期的产生子代种群建立基础。具体的变异操作如下：</div>
                    <img src="../static/Math/mathematicalModeling/17.png">
                    <div>其中g表示第g代的变异向量i个体，r1,r2,r3为常量指标。</div>
                </li>
                <li>
                    <div>种群的交叉</div>
                    <div>种群的交叉是为了产生多样性的子代向量，增强种群的多样性，使结构更加复杂，促使种群的结构化差异。具体的计算公式如下：</div>
                    <img src="../static/Math/mathematicalModeling/18.png">
                    <div>进行种群的交叉之后，为了挑选出最优子代，接下来将进行选择操作。</div>
                </li>
                <li>
                    <div>最优种群的选择</div>
                    <div>为使种群能从中挑选出最优子代，将执行贪婪选择操作。具体计算公式如下：</div>
                    <img src="../static/Math/mathematicalModeling/19.png">
                </li>
            </ol>
        </li>
        <li>
            <div>约束优化问题</div>
            <div>约束函数如下</div>
            <pre id="code_block">
                <span><code>"""</code></span>
                <span><code>min f(x1, x2, x3) = x1^2 + x2^2 + x3^2</code></span>
                <span><code>s.t.</code></span>
                <span><code>    x1*x2 >= 1</code></span>
                <span><code>    x1*x2 <= 5</code></span>
                <span><code>    x2 + x3 = 1</code></span>
                <span><code>    0 <= x1, x2, x3 <= 5</code></span>
                <span><code>"""</code></span>
            </pre>
            <div>构建约束函数</div>
            <pre id="code_block">
                <span><code>def obj_func(p):</code></span>
                <span><code>    x1, x2, x3 = p</code></span>
                <span><code>    return x1 ** 2 + x2 ** 2 + x3 ** 2</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>constraint_eq = [</code></span>
                <span><code>    lambda x: 1 - x[1] - x[2]</code></span>
                <span><code>]</code></span>
                <span><code></code></span>
                <span><code>constraint_ueq = [</code></span>
                <span><code>    lambda x: 1 - x[0] * x[1],</code></span>
                <span><code>    lambda x: x[0] * x[1] - 5</code></span>
                <span><code>]</code></span>
            </pre>
            <div>利用差分进化算法求解</div>
            <pre id="code_block">
                <span><code>from sko.DE import DE</code></span>
                <span><code></code></span>
                <span><code>de = DE(func=obj_func, n_dim=3, size_pop=50, max_iter=800, lb=[0, 0, 0], ub=[5, 5, 5],</code></span>
                <span><code>        constraint_eq=constraint_eq, constraint_ueq=constraint_ueq)</code></span>
                <span><code></code></span>
                <span><code>best_x, best_y = de.run()</code></span>
                <span><code>print('best_x:', best_x, '\n' + 'best_y:', best_y)</code></span>
            </pre>
            <div>结果如下</div>
            <img src="../static/Math/mathematicalModeling/20.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">遗传算法</span>
    </div>
    <ol type="I">
        <li>
            <div>原理讲解</div>
            <div>遗传算法（Genetic Algorithm，简称GA）起源于对生物系统所进行的计算机模拟研究，是一种随机全局搜索优化方法，它模拟了自然选择和遗传中发生的复制、交叉(crossover)和变异(mutation)等现象，从任一初始种群（Population）出发，通过随机选择、交叉和变异操作，产生一群更适合环境的个体，使群体进化到搜索空间中越来越好的区域，这样一代一代不断繁衍进化，最后收敛到一群最适应环境的个体（Individual），从而求得问题的优质解。</div>
        </li>
        <li>
            <div>流程分析</div>
            <img src="../static/Math/mathematicalModeling/21.png">
        </li>
        <li>
            <div>解最小值问题</div>
            <div>定义函数</div>
            <pre id="code_block">
                <span><code>import numpy as np</code></span>
                <span><code></code></span>
                <span><code>def schaffer(p):</code></span>
                <span><code>    """</code></span>
                <span><code>    This function has plenty of local minimum, with strong shocks</code></span>
                <span><code>    global minimum at (0,0) with value 0</code></span>
                <span><code>    """</code></span>
                <span><code>    x1, x2 = p</code></span>
                <span><code>    x = np.square(x1) + np.square(x2)</code></span>
                <span><code>    return 0.5 + (np.sin(x) - 0.5) / np.square(1 + 0.001 * x)</code></span>
            </pre>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.GA import GA</code></span>
                <span><code></code></span>
                <span><code>ga = GA(func=schaffer, n_dim=2, size_pop=50, max_iter=800, lb=[-1, -1], ub=[1, 1], precision=1e-7)</code></span>
                <span><code>best_x, best_y = ga.run()</code></span>
                <span><code>print('best_x:', best_x, '\n' + 'best_y:', best_y)</code></span>
            </pre>
            <div>结果如下</div>
            <img src="../static/Math/mathematicalModeling/21.png">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>import pandas as pd</code></span>
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code></code></span>
                <span><code>Y_history = pd.DataFrame(ga.all_history_Y)</code></span>
                <span><code>fig, ax = plt.subplots(2, 1)</code></span>
                <span><code>ax[0].plot(Y_history.index, Y_history.values, '.', color='red')</code></span>
                <span><code>Y_history.min(axis=1).cummin().plot(kind='line')</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/22.png">
        </li>
        <li>
            <div>旅行商问题</div>
            <div>数据生成办法同退火算法</div>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.GA import GA_TSP</code></span>
                <span><code></code></span>
                <span><code>ga_tsp = GA_TSP(func=cal_total_distance, n_dim=num_points, size_pop=50, max_iter=2000, prob_mut=1)</code></span>
                <span><code>best_points, best_distance = ga_tsp.run()</code></span>
                <span><code>print(best_points,best_distance)</code></span>
            </pre>
            <div>结果如下</div>
            <img src="../static/Math/mathematicalModeling/24.png">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>fig, ax = plt.subplots(1, 2)</code></span>
                <span><code>best_points_ = np.concatenate([best_points, [best_points[0]]])</code></span>
                <span><code>best_points_coordinate = points_coordinate[best_points_, :]</code></span>
                <span><code>ax[0].plot(best_points_coordinate[:, 0], best_points_coordinate[:, 1], 'o-r')</code></span>
                <span><code>ax[1].plot(ga_tsp.generation_best_Y)</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/25.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">粒子群算法</span>
    </div>
    <ol type="I">
        <li>
            <div>原理讲解</div>
            <div>将鸟群觅食行为和算法原理对应，如下图：</div>
            <img src="../static/Math/mathematicalModeling/26.png">
            <ol type="i">
                <li><div>PSO的基础：信息的社会共享</div></li>
                <li>
                    <div>粒子的两个属性：速度和位置（算法的两个核心要素）</div>
                    <div>速度表示粒子下一步迭代时移动的方向和距离，位置是所求解问题的一个解。</div>
                </li>
                <li>
                    <div>算法的6个重要参数</div>
                    <div>假设在D维搜索空间有N个粒子，每个粒子代表一个解，则：</div>
                    <img src="../static/Math/mathematicalModeling/27.png">
                </li>
                <li>
                    <div>速度更新公式</div>
                    <div>表述上叫速度，实际上就是粒子下一步迭代移动的距离和方向，也就是一个位置向量。</div>
                    <img src="../static/Math/mathematicalModeling/28.png">
                    <ol type="A">
                        <li>
                            <div>速度更新公式的解释</div>
                            <ol type="a">
                                <li>
                                    <div>第一项：惯性部分</div>
                                    <div>由惯性权重和粒子自身速度构成，表示粒子对先前自身运动状态的信任。</div>
                                </li>
                                <li>
                                    <div>第二项：认知部分</div>
                                    <div>表示粒子本身的思考，即粒子自己经验的部分，可理解为粒子当前位置与自身历史最优位置之间的距离和方向。</div>
                                </li>
                                <li>
                                    <div>第三项：社会部分</div>
                                    <div>表示粒子之间的信息共享与合作，即来源于群体中其他优秀粒子的经验，可理解为粒子当前位置与群体历史最优位置之间的距离和方向。</div>
                                </li>
                            </ol>
                        </li>
                        <li>
                            <div>速度更新公式的参数定义</div>
                            <img src="../static/Math/mathematicalModeling/29.png">
                        </li>
                        <li>
                            <div>速度的方向</div>
                            <div>粒子下一步迭代的移动方向 = 惯性方向 + 个体最优方向 + 群体最优方向</div>
                            <img src="../static/Math/mathematicalModeling/30.png">
                        </li>
                    </ol>
                </li>
                <li>
                    <div>位置更新公式</div>
                    <div>上一步的位置 + 下一步的速度</div>
                    <img src="../static/Math/mathematicalModeling/31.png">
                </li>
                <li>
                    <div>算法参数的详细解释</div>
                    <div><img src="../static/Math/mathematicalModeling/32.png"></div>
                    <div><img src="../static/Math/mathematicalModeling/33.png"></div>
                    <div><img src="../static/Math/mathematicalModeling/34.png"></div>
                </li>
            </ol>
        </li>
        <li>
            <div>流程分析</div>
            <img src="../static/Math/mathematicalModeling/35.png">
        </li>
        <li>
            <div>带约束的粒子群算法</div>
            <div>定义函数</div>
            <pre id="code_block">
                <span><code>def demo_func(x):</code></span>
                <span><code>    x1, x2, x3 = x</code></span>
                <span><code>    return x1 ** 2 + (x2 - 0.05) ** 2 + x3 ** 2</code></span>
            </pre>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.PSO import PSO</code></span>
                <span><code></code></span>
                <span><code>pso = PSO(func=demo_func, dim=3, pop=40, max_iter=150, lb=[0, -1, 0.5], ub=[1, 1, 1], w=0.8, c1=0.5, c2=0.5)</code></span>
                <span><code>pso.run()</code></span>
                <span><code>print('best_x is ', pso.gbest_x, 'best_y is', pso.gbest_y)</code></span>
            </pre>
            <div>结果如下</div>
            <img src="../static/Math/mathematicalModeling/36.png">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code></code></span>
                <span><code>plt.plot(pso.gbest_y_hist)</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/37.png">
        </li>
        <li>
            <div>不带约束的粒子群算法</div>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.PSO import PSO</code></span>
                <span><code></code></span>
                <span><code>pso = PSO(func=demo_func, dim=3)</code></span>
                <span><code>fitness = pso.run()</code></span>
                <span><code>print('best_x is ', pso.gbest_x, 'best_y is', pso.gbest_y)</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/38.png">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code></code></span>
                <span><code>plt.plot(pso.gbest_y_hist)</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/39.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">蚁群算法</span>
    </div>
    <ol type="I">
        <li>
            <div>原理讲解</div>
            <div>假如蚁群中所有蚂蚁的数量为m，所有城市之间的信息素用矩阵pheromone表示，最短路径为bestLength，最佳路径为bestTour。每只蚂蚁都有自己的内存，内存中用一个禁忌表（Tabu）来存储该蚂蚁已经访问过的城市，表示其在以后的搜索中将不能访问这些城市；还有用另外一个允许访问的城市表（Allowed）来存储它还可以访问的城市；另外还用一个矩阵（Delta）来存储它在一个循环（或者迭代）中给所经过的路径释放的信息素；还有另外一些数据，例如一些控制参数(α，β，ρ，Q)，该蚂蚁行走玩全程的总成本或距离（tourLength），等等。假定算法总共运行MAX_GEN次，运行时间为t。</div>
        </li>
        <li>
            <div>流程分析</div>
            <ol type="i">
                <li><div>初始化。</div></li>
                <li><div>为每只蚂蚁选择下一个节点。</div></li>
                <li><div>更新信息素矩阵。</div></li>
                <li><div>检查终止条件</div></li>
                <div>如果达到最大代数MAX_GEN，算法终止，转到第（5）步；否则，重新初始化所有的蚂蚁的Delt矩阵所有元素初始化为0，Tabu表清空，Allowed表中加入所有的城市节点。随机选择它们的起始位置（也可以人工指定）。在Tabu中加入起始节点，Allowed中去掉该起始节点，重复执行（2），（3）,(4)步。</div>
                <li><div>输出最优值</div></li>
            </ol>
        </li>
        <li>
            <div>代码实现</div>
            <pre id="code_block">
                <span><code>import random</code></span>
                <span><code>import copy</code></span>
                <span><code>import sys</code></span>
                <span><code>import tkinter  # //GUI模块</code></span>
                <span><code>import threading</code></span>
                <span><code>from functools import reduce</code></span>
                <span><code></code></span>
                <span><code># 参数</code></span>
                <span><code>"""</code></span>
                <span><code>ALPHA:信息启发因子，值越大，则蚂蚁选择之前走过的路径可能性就越大</code></span>
                <span><code>      ，值越小，则蚁群搜索范围就会减少，容易陷入局部最优</code></span>
                <span><code>BETA:Beta值越大，蚁群越就容易选择局部较短路径，这时算法收敛速度会</code></span>
                <span><code>     加快，但是随机性不高，容易得到局部的相对最优</code></span>
                <span><code>"""</code></span>
                <span><code>(ALPHA, BETA, RHO, Q) = (1.0, 2.0, 0.5, 100.0)</code></span>
                <span><code># 城市数，蚁群</code></span>
                <span><code>(city_num, ant_num) = (50, 50)</code></span>
                <span><code>distance_x = [</code></span>
                <span><code>    178, 272, 176, 171, 650, 499, 267, 703, 408, 437, 491, 74, 532,</code></span>
                <span><code>    416, 626, 42, 271, 359, 163, 508, 229, 576, 147, 560, 35, 714,</code></span>
                <span><code>    757, 517, 64, 314, 675, 690, 391, 628, 87, 240, 705, 699, 258,</code></span>
                <span><code>    428, 614, 36, 360, 482, 666, 597, 209, 201, 492, 294]</code></span>
                <span><code>distance_y = [</code></span>
                <span><code>    170, 395, 198, 151, 242, 556, 57, 401, 305, 421, 267, 105, 525,</code></span>
                <span><code>    381, 244, 330, 395, 169, 141, 380, 153, 442, 528, 329, 232, 48,</code></span>
                <span><code>    498, 265, 343, 120, 165, 50, 433, 63, 491, 275, 348, 222, 288,</code></span>
                <span><code>    490, 213, 524, 244, 114, 104, 552, 70, 425, 227, 331]</code></span>
                <span><code># 城市距离和信息素</code></span>
                <span><code>distance_graph = [[0.0 for col in range(city_num)] for raw in range(city_num)]</code></span>
                <span><code>pheromone_graph = [[1.0 for col in range(city_num)] for raw in range(city_num)]</code></span>
                <span><code></code></span>
                <span><code>class Ant(object):</code></span>
                <span><code></code></span>
                <span><code>    # 初始化</code></span>
                <span><code>    def __init__(self, ID):</code></span>
                <span><code></code></span>
                <span><code>        self.ID = ID  # ID</code></span>
                <span><code>        self.__clean_data()  # 随机初始化出生点</code></span>
                <span><code></code></span>
                <span><code>    # 初始数据</code></span>
                <span><code>    def __clean_data(self):</code></span>
                <span><code></code></span>
                <span><code>        self.path = []  # 当前蚂蚁的路径</code></span>
                <span><code>        self.total_distance = 0.0  # 当前路径的总距离</code></span>
                <span><code>        self.move_count = 0  # 移动次数</code></span>
                <span><code>        self.current_city = -1  # 当前停留的城市</code></span>
                <span><code>        self.open_table_city = [True for i in range(city_num)]  # 探索城市的状态</code></span>
                <span><code></code></span>
                <span><code>        city_index = random.randint(0, city_num - 1)  # 随机初始出生点</code></span>
                <span><code>        self.current_city = city_index</code></span>
                <span><code>        self.path.append(city_index)</code></span>
                <span><code>        self.open_table_city[city_index] = False</code></span>
                <span><code>        self.move_count = 1</code></span>
                <span><code></code></span>
                <span><code>    # 选择下一个城市</code></span>
                <span><code>    def __choice_next_city(self):</code></span>
                <span><code></code></span>
                <span><code>        next_city = -1</code></span>
                <span><code>        select_citys_prob = [0.0 for i in range(city_num)]  # 存储去下个城市的概率</code></span>
                <span><code>        total_prob = 0.0</code></span>
                <span><code></code></span>
                <span><code>        # 获取去下一个城市的概率</code></span>
                <span><code>        for i in range(city_num):</code></span>
                <span><code>            if self.open_table_city[i]:</code></span>
                <span><code>                try:</code></span>
                <span><code>                    # 计算概率：与信息素浓度成正比，与距离成反比</code></span>
                <span><code>                    select_citys_prob[i] = pow(pheromone_graph[self.current_city][i], ALPHA) * pow(</code></span>
                <span><code>                        (1.0 / distance_graph[self.current_city][i]), BETA)</code></span>
                <span><code>                    total_prob += select_citys_prob[i]</code></span>
                <span><code>                except ZeroDivisionError as e:</code></span>
                <span><code>                    print('Ant ID: {ID}, current city: {current}, target city: {target}'.format(ID=self.ID,</code></span>
                <span><code>                                                                                                current=self.current_city,</code></span>
                <span><code>                                                                                                target=i))</code></span>
                <span><code>                    sys.exit(1)</code></span>
                <span><code></code></span>
                <span><code>        # 轮盘选择城市</code></span>
                <span><code>        if total_prob > 0.0:</code></span>
                <span><code>            # 产生一个随机概率,0.0-total_prob</code></span>
                <span><code>            temp_prob = random.uniform(0.0, total_prob)</code></span>
                <span><code>            for i in range(city_num):</code></span>
                <span><code>                if self.open_table_city[i]:</code></span>
                <span><code>                    # 轮次相减</code></span>
                <span><code>                    temp_prob -= select_citys_prob[i]</code></span>
                <span><code>                    if temp_prob < 0.0:</code></span>
                <span><code>                        next_city = i</code></span>
                <span><code>                        break</code></span>
                <span><code></code></span>
                <span><code>        # 未从概率产生，顺序选择一个未访问城市</code></span>
                <span><code>        # if next_city == -1:</code></span>
                <span><code>        #     for i in range(city_num):</code></span>
                <span><code>        #         if self.open_table_city[i]:</code></span>
                <span><code>        #             next_city = i</code></span>
                <span><code>        #             break</code></span>
                <span><code></code></span>
                <span><code>        if (next_city == -1):</code></span>
                <span><code>            next_city = random.randint(0, city_num - 1)</code></span>
                <span><code>            while ((self.open_table_city[next_city]) == False):  # if==False,说明已经遍历过了</code></span>
                <span><code>                next_city = random.randint(0, city_num - 1)</code></span>
                <span><code></code></span>
                <span><code>        # 返回下一个城市序号</code></span>
                <span><code>        return next_city</code></span>
                <span><code></code></span>
                <span><code>    # 计算路径总距离</code></span>
                <span><code>    def __cal_total_distance(self):</code></span>
                <span><code></code></span>
                <span><code>        temp_distance = 0.0</code></span>
                <span><code></code></span>
                <span><code>        for i in range(1, city_num):</code></span>
                <span><code>            start, end = self.path[i], self.path[i - 1]</code></span>
                <span><code>            temp_distance += distance_graph[start][end]</code></span>
                <span><code></code></span>
                <span><code>        # 回路</code></span>
                <span><code>        end = self.path[0]</code></span>
                <span><code>        temp_distance += distance_graph[start][end]</code></span>
                <span><code>        self.total_distance = temp_distance</code></span>
                <span><code></code></span>
                <span><code>    # 移动操作</code></span>
                <span><code>    def __move(self, next_city):</code></span>
                <span><code></code></span>
                <span><code>        self.path.append(next_city)</code></span>
                <span><code>        self.open_table_city[next_city] = False</code></span>
                <span><code>        self.total_distance += distance_graph[self.current_city][next_city]</code></span>
                <span><code>        self.current_city = next_city</code></span>
                <span><code>        self.move_count += 1</code></span>
                <span><code></code></span>
                <span><code>    # 搜索路径</code></span>
                <span><code>    def search_path(self):</code></span>
                <span><code></code></span>
                <span><code>        # 初始化数据</code></span>
                <span><code>        self.__clean_data()</code></span>
                <span><code></code></span>
                <span><code>        # 搜素路径，遍历完所有城市为止</code></span>
                <span><code>        while self.move_count < city_num:</code></span>
                <span><code>            # 移动到下一个城市</code></span>
                <span><code>            next_city = self.__choice_next_city()</code></span>
                <span><code>            self.__move(next_city)</code></span>
                <span><code></code></span>
                <span><code>        # 计算路径总长度</code></span>
                <span><code>        self.__cal_total_distance()</code></span>
                <span><code></code></span>
                <span><code>class TSP(object):</code></span>
                <span><code></code></span>
                <span><code>    def __init__(self, root, width=800, height=600, n=city_num):</code></span>
                <span><code></code></span>
                <span><code>        # 创建画布</code></span>
                <span><code>        self.root = root</code></span>
                <span><code>        self.width = width</code></span>
                <span><code>        self.height = height</code></span>
                <span><code>        # 城市数目初始化为city_num</code></span>
                <span><code>        self.n = n</code></span>
                <span><code>        # tkinter.Canvas</code></span>
                <span><code>        self.canvas = tkinter.Canvas(</code></span>
                <span><code>            root,</code></span>
                <span><code>            width=self.width,</code></span>
                <span><code>            height=self.height,</code></span>
                <span><code>            bg="#EBEBEB",  # 背景白色</code></span>
                <span><code>            xscrollincrement=1,</code></span>
                <span><code>            yscrollincrement=1</code></span>
                <span><code>        )</code></span>
                <span><code>        self.canvas.pack(expand=tkinter.YES, fill=tkinter.BOTH)</code></span>
                <span><code>        self.title("TSP蚁群算法(n:初始化 e:开始搜索 s:停止搜索 q:退出程序)")</code></span>
                <span><code>        self.__r = 5</code></span>
                <span><code>        self.__lock = threading.RLock()  # 线程锁</code></span>
                <span><code></code></span>
                <span><code>        self.__bindEvents()</code></span>
                <span><code>        self.new()</code></span>
                <span><code></code></span>
                <span><code>        # 计算城市之间的距离</code></span>
                <span><code>        for i in range(city_num):</code></span>
                <span><code>            for j in range(city_num):</code></span>
                <span><code>                temp_distance = pow((distance_x[i] - distance_x[j]), 2) + pow((distance_y[i] - distance_y[j]), 2)</code></span>
                <span><code>                temp_distance = pow(temp_distance, 0.5)</code></span>
                <span><code>                distance_graph[i][j] = float(int(temp_distance + 0.5))</code></span>
                <span><code></code></span>
                <span><code>    # 按键响应程序</code></span>
                <span><code>    def __bindEvents(self):</code></span>
                <span><code></code></span>
                <span><code>        self.root.bind("q", self.quite)  # 退出程序</code></span>
                <span><code>        self.root.bind("n", self.new)  # 初始化</code></span>
                <span><code>        self.root.bind("e", self.search_path)  # 开始搜索</code></span>
                <span><code>        self.root.bind("s", self.stop)  # 停止搜索</code></span>
                <span><code></code></span>
                <span><code>    # 更改标题</code></span>
                <span><code>    def title(self, s):</code></span>
                <span><code></code></span>
                <span><code>        self.root.title(s)</code></span>
                <span><code></code></span>
                <span><code>    # 初始化</code></span>
                <span><code>    def new(self, evt=None):</code></span>
                <span><code></code></span>
                <span><code>        # 停止线程</code></span>
                <span><code>        self.__lock.acquire()</code></span>
                <span><code>        self.__running = False</code></span>
                <span><code>        self.__lock.release()</code></span>
                <span><code></code></span>
                <span><code>        self.clear()  # 清除信息</code></span>
                <span><code>        self.nodes = []  # 节点坐标</code></span>
                <span><code>        self.nodes2 = []  # 节点对象</code></span>
                <span><code></code></span>
                <span><code>        # 初始化城市节点</code></span>
                <span><code>        for i in range(len(distance_x)):</code></span>
                <span><code>            # 在画布上随机初始坐标</code></span>
                <span><code>            x = distance_x[i]</code></span>
                <span><code>            y = distance_y[i]</code></span>
                <span><code>            self.nodes.append((x, y))</code></span>
                <span><code>            # 生成节点椭圆，半径为self.__r</code></span>
                <span><code>            node = self.canvas.create_oval(x - self.__r,</code></span>
                <span><code>                                           y - self.__r, x + self.__r, y + self.__r,</code></span>
                <span><code>                                           fill="#ff0000",  # 填充红色</code></span>
                <span><code>                                           outline="#000000",  # 轮廓白色</code></span>
                <span><code>                                           tags="node",</code></span>
                <span><code>                                           )</code></span>
                <span><code>            self.nodes2.append(node)</code></span>
                <span><code>            # 显示坐标</code></span>
                <span><code>            self.canvas.create_text(x, y - 10,  # 使用create_text方法在坐标（302，77）处绘制文字</code></span>
                <span><code>                                    text='(' + str(x) + ',' + str(y) + ')',  # 所绘制文字的内容</code></span>
                <span><code>                                    fill='black'  # 所绘制文字的颜色为灰色</code></span>
                <span><code>                                    )</code></span>
                <span><code></code></span>
                <span><code>        # 顺序连接城市</code></span>
                <span><code>        # self.line(range(city_num))</code></span>
                <span><code></code></span>
                <span><code>        # 初始城市之间的距离和信息素</code></span>
                <span><code>        for i in range(city_num):</code></span>
                <span><code>            for j in range(city_num):</code></span>
                <span><code>                pheromone_graph[i][j] = 1.0</code></span>
                <span><code></code></span>
                <span><code>        self.ants = [Ant(ID) for ID in range(ant_num)]  # 初始蚁群</code></span>
                <span><code>        self.best_ant = Ant(-1)  # 初始最优解</code></span>
                <span><code>        self.best_ant.total_distance = 1 << 31  # 初始最大距离</code></span>
                <span><code>        self.iter = 1  # 初始化迭代次数</code></span>
                <span><code></code></span>
                <span><code>    # 将节点按order顺序连线</code></span>
                <span><code>    def line(self, order):</code></span>
                <span><code>        # 删除原线</code></span>
                <span><code>        self.canvas.delete("line")</code></span>
                <span><code></code></span>
                <span><code>        def line2(i1, i2):</code></span>
                <span><code>            p1, p2 = self.nodes[i1], self.nodes[i2]</code></span>
                <span><code>            self.canvas.create_line(p1, p2, fill="#000000", tags="line")</code></span>
                <span><code>            return i2</code></span>
                <span><code></code></span>
                <span><code>        # order[-1]为初始值</code></span>
                <span><code>        reduce(line2, order, order[-1])</code></span>
                <span><code></code></span>
                <span><code>    # 清除画布</code></span>
                <span><code>    def clear(self):</code></span>
                <span><code>        for item in self.canvas.find_all():</code></span>
                <span><code>            self.canvas.delete(item)</code></span>
                <span><code></code></span>
                <span><code>    # 退出程序</code></span>
                <span><code>    def quite(self, evt):</code></span>
                <span><code>        self.__lock.acquire()</code></span>
                <span><code>        self.__running = False</code></span>
                <span><code>        self.__lock.release()</code></span>
                <span><code>        self.root.destroy()</code></span>
                <span><code>        print(u"\n程序已退出...")</code></span>
                <span><code>        sys.exit()</code></span>
                <span><code></code></span>
                <span><code>    # 停止搜索</code></span>
                <span><code>    def stop(self, evt):</code></span>
                <span><code>        self.__lock.acquire()</code></span>
                <span><code>        self.__running = False</code></span>
                <span><code>        self.__lock.release()</code></span>
                <span><code></code></span>
                <span><code>    # 开始搜索</code></span>
                <span><code>    def search_path(self, evt=None):</code></span>
                <span><code></code></span>
                <span><code>        # 开启线程</code></span>
                <span><code>        self.__lock.acquire()</code></span>
                <span><code>        self.__running = True</code></span>
                <span><code>        self.__lock.release()</code></span>
                <span><code></code></span>
                <span><code>        while self.__running:</code></span>
                <span><code>            # 遍历每一只蚂蚁</code></span>
                <span><code>            for ant in self.ants:</code></span>
                <span><code>                # 搜索一条路径</code></span>
                <span><code>                ant.search_path()</code></span>
                <span><code>                # 与当前最优蚂蚁比较</code></span>
                <span><code>                if ant.total_distance < self.best_ant.total_distance:</code></span>
                <span><code>                    # 更新最优解</code></span>
                <span><code>                    self.best_ant = copy.deepcopy(ant)</code></span>
                <span><code>            # 更新信息素</code></span>
                <span><code>            self.__update_pheromone_gragh()</code></span>
                <span><code>            print(u"迭代次数：", self.iter, u"最佳路径总距离：", int(self.best_ant.total_distance))</code></span>
                <span><code>            # 连线</code></span>
                <span><code>            self.line(self.best_ant.path)</code></span>
                <span><code>            # 设置标题</code></span>
                <span><code>            self.title("TSP蚁群算法(n:随机初始 e:开始搜索 s:停止搜索 q:退出程序) 迭代次数: %d" % self.iter)</code></span>
                <span><code>            # 更新画布</code></span>
                <span><code>            self.canvas.update()</code></span>
                <span><code>            self.iter += 1</code></span>
                <span><code></code></span>
                <span><code>    # 更新信息素</code></span>
                <span><code>    def __update_pheromone_gragh(self):</code></span>
                <span><code></code></span>
                <span><code>        # 获取每只蚂蚁在其路径上留下的信息素</code></span>
                <span><code>        temp_pheromone = [[0.0 for col in range(city_num)] for raw in range(city_num)]</code></span>
                <span><code>        for ant in self.ants:</code></span>
                <span><code>            for i in range(1, city_num):</code></span>
                <span><code>                start, end = ant.path[i - 1], ant.path[i]</code></span>
                <span><code>                # 在路径上的每两个相邻城市间留下信息素，与路径总距离反比</code></span>
                <span><code>                temp_pheromone[start][end] += Q / ant.total_distance</code></span>
                <span><code>                temp_pheromone[end][start] = temp_pheromone[start][end]</code></span>
                <span><code></code></span>
                <span><code>        # 更新所有城市之间的信息素，旧信息素衰减加上新迭代信息素</code></span>
                <span><code>        for i in range(city_num):</code></span>
                <span><code>            for j in range(city_num):</code></span>
                <span><code>                pheromone_graph[i][j] = pheromone_graph[i][j] * RHO + temp_pheromone[i][j]</code></span>
                <span><code></code></span>
                <span><code>    # 主循环</code></span>
                <span><code>    def mainloop(self):</code></span>
                <span><code>        self.root.mainloop()</code></span>
                <span><code></code></span>
                <span><code>if __name__ == '__main__':</code></span>
                <span><code>    TSP(tkinter.Tk()).mainloop()</code></span>
            </pre>
        </li>
        <li>
            <div>旅行商问题</div>
            <div>数据生成办法同退火算法</div>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.ACA import ACA_TSP</code></span>
                <span><code></code></span>
                <span><code>aca = ACA_TSP(func=cal_total_distance, n_dim=num_points,</code></span>
                <span><code>              size_pop=50, max_iter=1000,</code></span>
                <span><code>              distance_matrix=distance_matrix)</code></span>
                <span><code></code></span>
                <span><code>best_points, best_distance = aca.run()</code></span>
                <span><code>print(best_points, best_distance)</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/40.png">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>from matplotlib.ticker import FormatStrFormatter</code></span>
                <span><code>fig, ax = plt.subplots(1, 2)</code></span>
                <span><code>best_points_ = np.concatenate([best_points, [best_points[0]]])</code></span>
                <span><code>best_points_coordinate = points_coordinate[best_points_, :]</code></span>
                <span><code>ax[0].plot(aca.y_best_history)</code></span>
                <span><code>ax[0].set_xlabel("Iteration")</code></span>
                <span><code>ax[0].set_ylabel("Distance")</code></span>
                <span><code>ax[1].plot(best_points_coordinate[:, 0], best_points_coordinate[:, 1],</code></span>
                <span><code>           marker='o', markerfacecolor='b', color='c', linestyle='-')</code></span>
                <span><code>ax[1].xaxis.set_major_formatter(FormatStrFormatter('%.3f'))</code></span>
                <span><code>ax[1].yaxis.set_major_formatter(FormatStrFormatter('%.3f'))</code></span>
                <span><code>ax[1].set_xlabel("Longitude")</code></span>
                <span><code>ax[1].set_ylabel("Latitude")</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/41.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">免疫优化算法</span>
    </div>
    <ol type="I">
        <li>
            <div>流程分析</div>
            <img src="../static/Math/mathematicalModeling/42.png">
        </li>
        <li>
            <div>旅行商问题</div>
            <div>数据生成办法同退火算法</div>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.IA import IA_TSP</code></span>
                <span><code></code></span>
                <span><code>ia_tsp = IA_TSP(func=cal_total_distance, n_dim=num_points, size_pop=500, max_iter=800, prob_mut=0.2,</code></span>
                <span><code>                T=0.7, alpha=0.95)</code></span>
                <span><code>best_points, best_distance = ia_tsp.run()</code></span>
                <span><code>print('best routine:', best_points, 'best_distance:', best_distance)</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/43.png">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>from matplotlib.ticker import FormatStrFormatter</code></span>
                <span><code>fig, ax = plt.subplots(1, 2)</code></span>
                <span><code>best_points_ = np.concatenate([best_points, [best_points[0]]])</code></span>
                <span><code>best_points_coordinate = points_coordinate[best_points_, :]</code></span>
                <span><code>ax[0].plot(ia_tsp.all_history_Y)</code></span>
                <span><code>ax[0].set_xlabel("Iteration")</code></span>
                <span><code>ax[0].set_ylabel("Distance")</code></span>
                <span><code>ax[1].plot(best_points_coordinate[:, 0], best_points_coordinate[:, 1],</code></span>
                <span><code>           marker='o', markerfacecolor='b', color='c', linestyle='-')</code></span>
                <span><code>ax[1].xaxis.set_major_formatter(FormatStrFormatter('%.3f'))</code></span>
                <span><code>ax[1].yaxis.set_major_formatter(FormatStrFormatter('%.3f'))</code></span>
                <span><code>ax[1].set_xlabel("Longitude")</code></span>
                <span><code>ax[1].set_ylabel("Latitude")</code></span>
                <span><code>plt.show()</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/44.png">
        </li>

    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">人工鱼群算法</span>
    </div>
    <ol type="I">
        <li>
            <div>流程分析</div>
            <img src="../static/Math/mathematicalModeling/45.png">
        </li>
        <li>
            <div>最小值问题</div>
            <div>生成函数</div>
            <pre id="code_block">
                <span><code>def func(x):</code></span>
                <span><code>    x1, x2 = x</code></span>
                <span><code>    return 1 / x1 ** 2 + x1 ** 2 + 1 / x2 ** 2 + x2 ** 2</code></span>
            </pre>
            <div>求解</div>
            <pre id="code_block">
                <span><code>from sko.AFSA import AFSA</code></span>
                <span><code></code></span>
                <span><code>afsa = AFSA(func, n_dim=2, size_pop=50, max_iter=300,</code></span>
                <span><code>            max_try_num=100, step=0.5, visual=0.3,</code></span>
                <span><code>            q=0.98, delta=0.5)</code></span>
                <span><code>best_x, best_y = afsa.run()</code></span>
                <span><code>print(best_x, best_y)</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/46.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">GS（Gale-Shapley）算法</span>
    </div>
    <ol type="I">
        <li>
            <div>算法原理</div>
            <div>设有ABCD四个女生，WXYZ四个男生，设法在他们之间建立一个完美匹配M，要求每位女生只能有一个男生，每位男生只能有一个女生，而且不能出现不稳定的情况.</div>
            <div>所谓不稳定的情况是指: 假设匹配中包含A-W与B-X，但是W在现在匹配的A与未匹配的B之中更喜欢B，同时B在现在匹配的X与未匹配的W之中更青睐W，所以W和B将会私下在一起，并解除关系。</div>
            <div>为了解决这个问题，有如下算法：</div>
            <ol type="i">
                <li>
                    <div>第一个男生向他所理想的第一位女生发出apply，由于女生此时尚未收到其他男生的apply，所以她选择接受</div>
                </li>
                <li>
                    <div>第二个男生向他所理想的第一位女生发出apply，假设(if)此人此时尚未收到其他男生的apply，则她选择接受；否则，若(else if)此人此时已经收到其他男生的apply，但是她更加偏好已经在一起的男生，则他选择拒绝；再或者(else)此人此时虽然收到了apply，但是她更加偏好新来的男生，则她选择毁掉之前的关系，接受这个男生</div>
                </li>
                <li>
                    <div>其他的男生将按照Step2中的样子继续执行，当条件：存在某个男生没有匹配同时还没有向所有女生发apply不满足时，算法终止</div>
                </li>
            </ol>
        </li>
        <li>
            <div>代码实现</div>
            <pre id="code_block">
                <span><code>class GS:</code></span>
                <span><code>    def __init__(self, girls=None, boys=None):</code></span>
                <span><code>        self.girls = girls</code></span>
                <span><code>        self.boys = boys</code></span>
                <span><code></code></span>
                <span><code>    @staticmethod</code></span>
                <span><code>    def _shuffle(arr, random_state=None):</code></span>
                <span><code>        from random import shuffle</code></span>
                <span><code>        if random_state is not None:</code></span>
                <span><code>            from random import seed</code></span>
                <span><code>            seed(random_state)</code></span>
                <span><code>        arr_new = arr.copy()</code></span>
                <span><code>        shuffle(arr_new)</code></span>
                <span><code>        return arr_new</code></span>
                <span><code></code></span>
                <span><code>    def random(self, n_girls, n_boys, random_state=None):</code></span>
                <span><code>        if random_state is not None:</code></span>
                <span><code>            from random import seed, randint</code></span>
                <span><code>            seed(random_state)</code></span>
                <span><code>            random_seed = [randint(0, 100) for _ in range(max(n_boys, n_girls))]</code></span>
                <span><code>        else:</code></span>
                <span><code>            random_seed = [None] * max(n_boys, n_girls)</code></span>
                <span><code>        self.girls = [self._shuffle([*range(n_boys)], random_seed[i]) for i in range(n_girls)]</code></span>
                <span><code>        self.boys = [self._shuffle([*range(n_girls)], random_seed[i]) for i in range(n_boys)]</code></span>
                <span><code></code></span>
                <span><code>    @property</code></span>
                <span><code>    def n_girls(self):</code></span>
                <span><code>        return len(self.girls)</code></span>
                <span><code></code></span>
                <span><code>    @property</code></span>
                <span><code>    def n_boys(self):</code></span>
                <span><code>        return len(self.boys)</code></span>
                <span><code></code></span>
                <span><code>    @staticmethod</code></span>
                <span><code>    def findBest(boyArr, girlChoose):</code></span>
                <span><code>        for g in girlChoose:</code></span>
                <span><code>            if g in boyArr:</code></span>
                <span><code>                return g</code></span>
                <span><code></code></span>
                <span><code>    def run(self):</code></span>
                <span><code>        if self.n_boys == self.n_girls:</code></span>
                <span><code>            container = [[] for _ in range(self.n_girls)]</code></span>
                <span><code>            for index, boy in enumerate(self.boys):</code></span>
                <span><code>                container[boy[0]].append(boy + [index, 0])</code></span>
                <span><code>            while True:</code></span>
                <span><code>                for index, cont in enumerate(container):</code></span>
                <span><code>                    if len(cont) == 0:</code></span>
                <span><code>                        continue</code></span>
                <span><code>                    if len(cont) > 1:</code></span>
                <span><code>                        boys_arr = [c[-2] for c in cont]</code></span>
                <span><code>                        boyChooseId = self.findBest(boys_arr, self.girls[index])</code></span>
                <span><code>                        for c in cont:</code></span>
                <span><code>                            if c[-2] != boyChooseId:</code></span>
                <span><code>                                c[-1] += 1</code></span>
                <span><code>                                container[c[c[-1]]].append(c)</code></span>
                <span><code>                            else:</code></span>
                <span><code>                                boyChoose = c.copy()</code></span>
                <span><code>                        container[index] = [boyChoose.copy()]</code></span>
                <span><code>                        break</code></span>
                <span><code>                else:</code></span>
                <span><code>                    break</code></span>
                <span><code>            self.boys = [cont[0][:-2] for cont in container]</code></span>
                <span><code>            ans = {value: cont[0][-2] for value, cont in enumerate(container)}</code></span>
                <span><code>            ans['girls'] = 'boys'</code></span>
                <span><code>            return ans</code></span>
                <span><code>        elif self.n_girls > self.n_boys:</code></span>
                <span><code>            container = [[] for _ in range(self.n_girls)]</code></span>
                <span><code>            for index, boy in enumerate(self.boys):</code></span>
                <span><code>                container[boy[0]].append(boy + [index, 0])</code></span>
                <span><code>            while True:</code></span>
                <span><code>                for index, cont in enumerate(container):</code></span>
                <span><code>                    if len(cont) == 0:</code></span>
                <span><code>                        continue</code></span>
                <span><code>                    if len(cont) > 1:</code></span>
                <span><code>                        boys_arr = [c[-2] for c in cont]</code></span>
                <span><code>                        boyChooseId = self.findBest(boys_arr, self.girls[index])</code></span>
                <span><code>                        for c in cont:</code></span>
                <span><code>                            if c[-2] != boyChooseId:</code></span>
                <span><code>                                c[-1] += 1</code></span>
                <span><code>                                container[c[c[-1]]].append(c)</code></span>
                <span><code>                            else:</code></span>
                <span><code>                                boyChoose = c.copy()</code></span>
                <span><code>                        container[index] = [boyChoose.copy()]</code></span>
                <span><code>                        break</code></span>
                <span><code>                else:</code></span>
                <span><code>                    break</code></span>
                <span><code>            self.boys = [cont[0][:-2] if cont else [] for cont in container]</code></span>
                <span><code>            ans = {}</code></span>
                <span><code>            for value, cont in enumerate(container):</code></span>
                <span><code>                if cont:</code></span>
                <span><code>                    ans[value] = cont[0][-2]</code></span>
                <span><code>                else:</code></span>
                <span><code>                    ans[value] = None</code></span>
                <span><code>            ans['girls'] = 'boys'</code></span>
                <span><code>            return ans</code></span>
                <span><code>        else:</code></span>
                <span><code>            container = [[] for _ in range(self.n_boys)]</code></span>
                <span><code>            for index, girl in enumerate(self.girls):</code></span>
                <span><code>                container[girl[0]].append(girl + [index, 0])</code></span>
                <span><code>            while True:</code></span>
                <span><code>                for index, cont in enumerate(container):</code></span>
                <span><code>                    if len(cont) == 0:</code></span>
                <span><code>                        continue</code></span>
                <span><code>                    if len(cont) > 1:</code></span>
                <span><code>                        girls_arr = [c[-2] for c in cont]</code></span>
                <span><code>                        girlChooseId = self.findBest(girls_arr, self.boys[index])</code></span>
                <span><code>                        for c in cont:</code></span>
                <span><code>                            if c[-2] != girlChooseId:</code></span>
                <span><code>                                c[-1] += 1</code></span>
                <span><code>                                container[c[c[-1]]].append(c)</code></span>
                <span><code>                            else:</code></span>
                <span><code>                                girlChoose = c.copy()</code></span>
                <span><code>                        container[index] = [girlChoose.copy()]</code></span>
                <span><code>                        break</code></span>
                <span><code>                else:</code></span>
                <span><code>                    break</code></span>
                <span><code>            self.girls = [cont[0][:-2] if cont else [] for cont in container]</code></span>
                <span><code>            ans = {}</code></span>
                <span><code>            for value, cont in enumerate(container):</code></span>
                <span><code>                if cont:</code></span>
                <span><code>                    ans[value] = cont[0][-2]</code></span>
                <span><code>                else:</code></span>
                <span><code>                    ans[value] = None</code></span>
                <span><code>            ans['boys'] = 'girls'</code></span>
                <span><code>            return ans</code></span>
            </pre>
            <div>生成每个男生（女生）对女生（男生）的喜欢程度排名</div>
            <pre id="code_block">
                <span><code>gs = GS()</code></span>
                <span><code>gs.random(5, 5, 42)</code></span>
                <span><code>print("boys:   " + str(gs.boys))</code></span>
                <span><code>print('girls:  ' + str(gs.girls))</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/47.png">
            <div>求解</div>
            <pre id="code_block">
                <span><code>print(gs.run())</code></span>
                <span><code>print("boys:   " + str(gs.boys))</code></span>
                <span><code>print('girls:  ' + str(gs.girls))</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/48.png">
            <div>也可以解决男女人数不相等的情况</div>
            <pre id="code_block">
                <span><code>gs = GS()</code></span>
                <span><code>gs.random(5, 6, 42)</code></span>
                <span><code>print(gs.run())</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/49.png">
        </li>
    </ol>
    <div class="tit">
        <span style="color:red;font-size:40px;">灰色关联分析</span>
    </div>
    <ol type="I">
        <li>
            <div>作用：</div>
            <div>灰色关联度分析对于一个系统发展变化态势提供了量化的度量，非常适合动态历程分析。</div>
        </li>
        <li>
            <div>步骤：</div>
            <ol type="i">
                <li><div>确定分析数列</div></li>
                <li>
                    <div>变量的无量纲化</div>
                    <div>1、标准化</div>
                    <div>2、归一化</div>
                </li>
                <li>
                    <div>计算关联系数</div>
                </li>
            </ol>
        </li>
        <li>
            <div>代码实现</div>
            <div>获取数据集</div>
            <pre id="code_block">
                <span><code>import pandas as pd</code></span>
                <span><code>import numpy as np</code></span>
                <span><code>from sklearn.datasets import load_wine</code></span>
                <span><code></code></span>
                <span><code>data = load_wine().data</code></span>
                <span><code>feature = load_wine().feature_names</code></span>
                <span><code>wine = pd.DataFrame({feature[i]: data[:,i] for i in range((len(feature)))})</code></span>
            </pre>
            <div>求灰色关联度矩阵</div>
            <pre id="code_block">
                <span><code>def dimensionlessProcessing(df_values, df_columns):</code></span>
                <span><code>    from sklearn.preprocessing import StandardScaler</code></span>
                <span><code>    scaler = StandardScaler()</code></span>
                <span><code>    res = scaler.fit_transform(df_values)</code></span>
                <span><code>    return pd.DataFrame(res, columns=df_columns)</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code># 求第一列(影响因素)和其它所有列(影响因素)的灰色关联值</code></span>
                <span><code>def GRA_ONE(data, m=0):  # m为参考列</code></span>
                <span><code>    # 标准化</code></span>
                <span><code>    data = dimensionlessProcessing(data.values, data.columns)</code></span>
                <span><code>    # 参考数列</code></span>
                <span><code>    std = data.iloc[:, m]</code></span>
                <span><code>    # 比较数列</code></span>
                <span><code>    ce = data.copy()</code></span>
                <span><code></code></span>
                <span><code>    n = ce.shape[0]</code></span>
                <span><code>    m = ce.shape[1]</code></span>
                <span><code></code></span>
                <span><code>    # 与参考数列比较，相减</code></span>
                <span><code>    grap = np.zeros([n, m])</code></span>
                <span><code>    for i in range(m):</code></span>
                <span><code>        for j in range(n):</code></span>
                <span><code>            grap[j, i] = abs(ce.iloc[j, i] - std[j])</code></span>
                <span><code></code></span>
                <span><code>    # 取出矩阵中的最大值和最小值</code></span>
                <span><code>    mmax = np.amax(grap)</code></span>
                <span><code>    mmin = np.amin(grap)</code></span>
                <span><code>    ρ = 0.5  # 灰色分辨系数</code></span>
                <span><code></code></span>
                <span><code>    # 计算值</code></span>
                <span><code>    grap = pd.DataFrame(grap).applymap(lambda x: (mmin + ρ * mmax) / (x + ρ * mmax))</code></span>
                <span><code></code></span>
                <span><code>    # 求均值，得到灰色关联值</code></span>
                <span><code>    RT = grap.mean(axis=0)</code></span>
                <span><code>    return pd.Series(RT)</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code># 调用GRA_ONE，求得所有因素之间的灰色关联值</code></span>
                <span><code>def GRA(data):</code></span>
                <span><code>    list_columns = np.arange(data.shape[1])</code></span>
                <span><code>    df_local = pd.DataFrame(columns=list_columns)</code></span>
                <span><code>    for i in np.arange(data.shape[1]):</code></span>
                <span><code>        df_local[df_local.columns[i]] = GRA_ONE(data, m=i)</code></span>
                <span><code>    return df_local</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>pd.set_option('display.max_columns', None)</code></span>
                <span><code>data_gra = GRA(wine)</code></span>
                <span><code>print(data_gra)</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/50.png" height="400px">
            <img src="../static/Math/mathematicalModeling/51.png" height="400px">
            <div>可视化</div>
            <pre id="code_block">
                <span><code>import seaborn as sns  # 可视化图形调用库</code></span>
                <span><code>import matplotlib.pyplot as plt</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>def ShowGRAHeatMap(data):</code></span>
                <span><code>    # 色彩集</code></span>
                <span><code>    colormap = plt.cm.RdBu</code></span>
                <span><code>    plt.figure(figsize=(18, 16))</code></span>
                <span><code>    plt.title('Person Correlation of Features', y=1.05, size=18)</code></span>
                <span><code>    sns.heatmap(data.astype(float), linewidths=0.1, vmax=1.0, square=True, \</code></span>
                <span><code>                cmap=colormap, linecolor='white', annot=True)</code></span>
                <span><code>    plt.show()</code></span>
                <span><code></code></span>
                <span><code></code></span>
                <span><code>ShowGRAHeatMap(data_gra)</code></span>
            </pre>
            <img src="../static/Math/mathematicalModeling/52.png">
        </li>
    </ol>
</body>
</html>